{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Delver is an efficient game framework intended for solving major issues with frameworks like Knit & Volt, while also providing on its own a few features such as performant networking. However, why use Delver over Knit & Volt? Why Use Delver Unified Singleton : The singleton which you use for running code is unified for the server and the client, so no need to fear the overcomplications you get from the service-controller paradigm, just as simple as Runner . Running Runners in Async/Sync Execution Models : You have the option to whether run your runners in an async thread or a sync thread (main thread) . If a synced runner blocks execution, the other OnRuns of other runners would also be blocked. A Performant Networking Layer : Delver offers you you to create \"endpoints\" from the server that will be executed from the client. Besides, the performant of the said endpoints would be optimal to a degree due to the networking library being used (BridgeNet by ffrostfall) . Lightweight : Delver's codebase is ~200 code lines, and it only requires a module to function which is BridgeNet. Beside implemenation details, Delver doesn't really come with a version that is bundled with a few packages as this doesn't line up with the vision behind Delver. No Mutable Global State : Any practices that exactly mirror _G storage practices are entirely disallowed in Delver. The only way for your runners to have data stored in them is to name them a name that starts with either _ or M_ - assuming that the datatype isn't a function or a table. More info would be discussed later","title":"Introduction"},{"location":"#introduction","text":"Delver is an efficient game framework intended for solving major issues with frameworks like Knit & Volt, while also providing on its own a few features such as performant networking. However, why use Delver over Knit & Volt?","title":"Introduction"},{"location":"#why-use-delver","text":"Unified Singleton : The singleton which you use for running code is unified for the server and the client, so no need to fear the overcomplications you get from the service-controller paradigm, just as simple as Runner . Running Runners in Async/Sync Execution Models : You have the option to whether run your runners in an async thread or a sync thread (main thread) . If a synced runner blocks execution, the other OnRuns of other runners would also be blocked. A Performant Networking Layer : Delver offers you you to create \"endpoints\" from the server that will be executed from the client. Besides, the performant of the said endpoints would be optimal to a degree due to the networking library being used (BridgeNet by ffrostfall) . Lightweight : Delver's codebase is ~200 code lines, and it only requires a module to function which is BridgeNet. Beside implemenation details, Delver doesn't really come with a version that is bundled with a few packages as this doesn't line up with the vision behind Delver. No Mutable Global State : Any practices that exactly mirror _G storage practices are entirely disallowed in Delver. The only way for your runners to have data stored in them is to name them a name that starts with either _ or M_ - assuming that the datatype isn't a function or a table. More info would be discussed later","title":"Why Use Delver"},{"location":"API/","text":"Still in the works","title":"API"},{"location":"Home/basic-usage/","text":"Basic Usage Assuming that you have installed Delver and put it in ReplicatedStorage , now we can reference it like this: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Delver = require ( ReplicatedStorage . Packages . delver ) To register a runner to Delver, we use the Delver.AddRunner helper function. This function in your Delver journey would be the one that either makes you hate every second of yourself, or to be grateful to it due to how many bugs it saved you from crossing upon. Adding a runner is as simple as: local MoneyRunner = Delver . AddRunner ({ Name = \"MoneyRunner\" , Sync = false , _money = 0 , GetMoney = function ( self ) return self . _money end , SetMoney = function ( self , value ) if type ( value ) == \"number\" then self . _money = value return true else return false end end }) Runner's Defining This way of defining runners isn't a \"strict\" practice that you should always follow. I like using this way, so I use it although you are free to use whatever defining method you would like as long as it doesn't mess with anything. Now that we have added a base runner, let's start Delver. We can do so by doing: Delver . Start () Delver's Start function yields the current thread until it finishes its work, so directly using another function Delver provides that is Delver.ReturnRunnerWithName would be considered safe. So, to use our MoneyRunner , we could retrieve it and then do whatever we want with it: local MoneyRunner = Delver . ReturnRunnerWithName ( \"MoneyRunner\" ) local function cprint (...) print ( \"current value:\" , ...) end cprint ( MoneyRunner : GetMoney ()) MoneyRunner : SetMoney ( 40 ) cprint ( MoneyRunner : GetMoney ()) Congrats! You just used Delver for the first time! Though this example was just an introduction usage to Delver, the ~~heaviy~~ interesting stuff are coming! For now, try playing around with our MoneyRunner , specifically with: _money 's name, trying removing the _ and observe what happens or... adding self.writeUses = (self.writeUses or 1) + 1 after writing _money and see what happens Try adding a few other functions","title":"Basic Usage"},{"location":"Home/basic-usage/#basic-usage","text":"Assuming that you have installed Delver and put it in ReplicatedStorage , now we can reference it like this: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Delver = require ( ReplicatedStorage . Packages . delver ) To register a runner to Delver, we use the Delver.AddRunner helper function. This function in your Delver journey would be the one that either makes you hate every second of yourself, or to be grateful to it due to how many bugs it saved you from crossing upon. Adding a runner is as simple as: local MoneyRunner = Delver . AddRunner ({ Name = \"MoneyRunner\" , Sync = false , _money = 0 , GetMoney = function ( self ) return self . _money end , SetMoney = function ( self , value ) if type ( value ) == \"number\" then self . _money = value return true else return false end end }) Runner's Defining This way of defining runners isn't a \"strict\" practice that you should always follow. I like using this way, so I use it although you are free to use whatever defining method you would like as long as it doesn't mess with anything. Now that we have added a base runner, let's start Delver. We can do so by doing: Delver . Start () Delver's Start function yields the current thread until it finishes its work, so directly using another function Delver provides that is Delver.ReturnRunnerWithName would be considered safe. So, to use our MoneyRunner , we could retrieve it and then do whatever we want with it: local MoneyRunner = Delver . ReturnRunnerWithName ( \"MoneyRunner\" ) local function cprint (...) print ( \"current value:\" , ...) end cprint ( MoneyRunner : GetMoney ()) MoneyRunner : SetMoney ( 40 ) cprint ( MoneyRunner : GetMoney ()) Congrats! You just used Delver for the first time! Though this example was just an introduction usage to Delver, the ~~heaviy~~ interesting stuff are coming! For now, try playing around with our MoneyRunner , specifically with: _money 's name, trying removing the _ and observe what happens or... adding self.writeUses = (self.writeUses or 1) + 1 after writing _money and see what happens Try adding a few other functions","title":"Basic Usage"},{"location":"Home/lifecycles/","text":"Lifecycles and Executions Now, you are gonna learn about one of the most fundemental concepts in Delver - Lifecycles! They are super important features that allow for robust code without hacky and lengthy methods. The Problem Let's assume that we have a really simple framework that loads modulescripts that return a function and then call them. This works, until you need communication between those modulescripts . Here's a simple module that we will call MoneyHandler -- MoneyHandler.lua return function () -- this is the execution point for this handler local moneyRecord = {} game . Players . PlayerAdded : Connect ( function ( plr ) moneyRecprd [ plr ] = 0 end ) game . Players . PlayerRemoving : Connect ( function ( plr ) moneyRecord [ plr ] = nil end ) local ActionEvent = < path_to_a_bindable > ActionEvent : Connect ( function ( plr ) moneyRecord [ plr ] += 10 end ) end This is simple, and it works! However, how are we gonna make this work when we don't use bindable events? Maybe we have a client handler for a player that manages the melee system and sends requests to a server handler that then will ask this handler to increment the player's money? Yup, implementing cross-communication will become a very annoying issue since we don't have guarantees that our data or our core jobs are initialized - and by the way, this simple example is no different than a normal script - communication is impossible without bindables! Fix: Lifecycle Functions To solve this, we need two separated execution points, one for initializng jobs for cross-communication, and the other for startup. And Delver's OnPrepare and OnRun are exactly that! When running OnPrepare , all Runners are already added to the public namespace, however not ready to be consumed , so it is fine to fetch the runner, but not in any way use it. After all OnPrepare s are ran, it is guaranteed that our runners are now ready for external consuming, and therefore, ready for startup or aka, all OnRun s are called, either at the same caller thread if the runner's Sync is true, or in a separate thread if the said property is false. Now that we know OnRun and OnPrepare , let's rewrite the MoneyHandler into a cool Runner that is called MoneyRunner . Delver . addRunner ({ Name = \"MoneyRunner\" , Sync = false , _moneyRecord = {}, OnPrepare = function ( self ) self . _ActionEvent = < path_to_Bindable > game . Players . PlayerAdded : Connect ( function ( plr ) self . _moneyRecord [ plr ] = 0 end ) game . Players . PlayerRemoving : Connect ( function ( plr ) self . _moneyRecord [ plr ] = nil end ) end , OnRun = function ( self ) self . _ActionEvent : Connect ( function ( plr , reward ) self . _moneyRecord [ plr ] += reward end ) end }) This works and is simple, and we now can implement cross-runner communication ! Assuming that we have a server runner that manages the requests from other client runners to register their hits and that runner needs to notify MoneyRunner , we can implement it easily! Just Delver.ReturnRunnerWithName(\"ServerRunner\") in MoneyRunner 's OnPrepare and then connect to the appropriate signal in the OnRun . OnRun and OnPrepare are powerful tools for scalable communication, however, there are other three lifecycle functions to make your life a little bit easier, and they are OnRender , OnStepped and OnHeartbeat . It's obvious that these functions are just a shortcut for RunService 's event, and so, they inherit the same behavior (same paramters) and limitations (OnRender doesn't work in the server) . OnRender: {... OnRender = function ( self , deltaTime ) end , ...} OnHeartbeat: {... OnHeartbeat = function ( self , deltaTime ) end , ...} OnStepped: {... OnStepped = function ( self , time , deltaTime ) end , ...} Now that you learnt the wonders of Delver's lifecycles, you are ready for the lands of Delver's built-in networking!","title":"Lifecycles and Execution"},{"location":"Home/lifecycles/#lifecycles-and-executions","text":"Now, you are gonna learn about one of the most fundemental concepts in Delver - Lifecycles! They are super important features that allow for robust code without hacky and lengthy methods.","title":"Lifecycles and Executions"},{"location":"Home/lifecycles/#the-problem","text":"Let's assume that we have a really simple framework that loads modulescripts that return a function and then call them. This works, until you need communication between those modulescripts . Here's a simple module that we will call MoneyHandler -- MoneyHandler.lua return function () -- this is the execution point for this handler local moneyRecord = {} game . Players . PlayerAdded : Connect ( function ( plr ) moneyRecprd [ plr ] = 0 end ) game . Players . PlayerRemoving : Connect ( function ( plr ) moneyRecord [ plr ] = nil end ) local ActionEvent = < path_to_a_bindable > ActionEvent : Connect ( function ( plr ) moneyRecord [ plr ] += 10 end ) end This is simple, and it works! However, how are we gonna make this work when we don't use bindable events? Maybe we have a client handler for a player that manages the melee system and sends requests to a server handler that then will ask this handler to increment the player's money? Yup, implementing cross-communication will become a very annoying issue since we don't have guarantees that our data or our core jobs are initialized - and by the way, this simple example is no different than a normal script - communication is impossible without bindables!","title":"The Problem"},{"location":"Home/lifecycles/#fix-lifecycle-functions","text":"To solve this, we need two separated execution points, one for initializng jobs for cross-communication, and the other for startup. And Delver's OnPrepare and OnRun are exactly that! When running OnPrepare , all Runners are already added to the public namespace, however not ready to be consumed , so it is fine to fetch the runner, but not in any way use it. After all OnPrepare s are ran, it is guaranteed that our runners are now ready for external consuming, and therefore, ready for startup or aka, all OnRun s are called, either at the same caller thread if the runner's Sync is true, or in a separate thread if the said property is false. Now that we know OnRun and OnPrepare , let's rewrite the MoneyHandler into a cool Runner that is called MoneyRunner . Delver . addRunner ({ Name = \"MoneyRunner\" , Sync = false , _moneyRecord = {}, OnPrepare = function ( self ) self . _ActionEvent = < path_to_Bindable > game . Players . PlayerAdded : Connect ( function ( plr ) self . _moneyRecord [ plr ] = 0 end ) game . Players . PlayerRemoving : Connect ( function ( plr ) self . _moneyRecord [ plr ] = nil end ) end , OnRun = function ( self ) self . _ActionEvent : Connect ( function ( plr , reward ) self . _moneyRecord [ plr ] += reward end ) end }) This works and is simple, and we now can implement cross-runner communication ! Assuming that we have a server runner that manages the requests from other client runners to register their hits and that runner needs to notify MoneyRunner , we can implement it easily! Just Delver.ReturnRunnerWithName(\"ServerRunner\") in MoneyRunner 's OnPrepare and then connect to the appropriate signal in the OnRun . OnRun and OnPrepare are powerful tools for scalable communication, however, there are other three lifecycle functions to make your life a little bit easier, and they are OnRender , OnStepped and OnHeartbeat . It's obvious that these functions are just a shortcut for RunService 's event, and so, they inherit the same behavior (same paramters) and limitations (OnRender doesn't work in the server) . OnRender: {... OnRender = function ( self , deltaTime ) end , ...} OnHeartbeat: {... OnHeartbeat = function ( self , deltaTime ) end , ...} OnStepped: {... OnStepped = function ( self , time , deltaTime ) end , ...} Now that you learnt the wonders of Delver's lifecycles, you are ready for the lands of Delver's built-in networking!","title":"Fix: Lifecycle Functions"},{"location":"Home/networking/","text":"Networking & Middleware Often times you need to \"expose\" some functions from the server to the client. Thankfully, Delver has a built-in solution for that, and it is ClientEndpoints! They are little special entities that are allowed to live on the server realm that allow for client-server-client communication. You define ClientEndpoints in this way: -- server Delver . addRunner ({... ClientEndpoints = { func = function ( plr , ...) return true end , func2 = function ( plr , ...) return false end } ...}) Internally, Delver sets up all the networking infrastructure needed for this kind of communication, and then adds the server runner to every client's Runner table, which means that it can be used on the client by Delver.ReturnRunnerWithName . Another thing cool about ClientEndpoints is that they behave like functions! Meaning on the client, if we did Runner:func() , it would return true - and to ensure that behavior, all of these functions yield. Leaving return nil in Endpoints Due to the networking library Delver uses, you must explicitly return a value in order for the client to not yield forever. Now that you know how to create Endpoints, let's learn how to use middleware! Just like ClientEndpoints, Middleware is a server-only entity however, the special thing is that Middleware allows for more control over how Delver handles internal requests for ClientEndpoints. To define Middleware in a server runner: Delver . addRunner ({... Middleware = { function ( plr , NameFunc , ...) -- runs first return plr , NameFunc , ... end , function ( plr , NameFunc , ...) -- runs second return nil -- drops remote request end , } ...}) Internally, whenever an endpoint request comes in, Delver calls these functions in order, and will drop the reqeust if a nil was solely returned. While argument injection can be useful, it is important to be aware of the dangers of mutating NameFunc . To cut a long story short, any mutation of the NameFunc may result in Delver dropping requests or completely choosing a different endpoint.","title":"Networking and Middleware"},{"location":"Home/networking/#networking-middleware","text":"Often times you need to \"expose\" some functions from the server to the client. Thankfully, Delver has a built-in solution for that, and it is ClientEndpoints! They are little special entities that are allowed to live on the server realm that allow for client-server-client communication. You define ClientEndpoints in this way: -- server Delver . addRunner ({... ClientEndpoints = { func = function ( plr , ...) return true end , func2 = function ( plr , ...) return false end } ...}) Internally, Delver sets up all the networking infrastructure needed for this kind of communication, and then adds the server runner to every client's Runner table, which means that it can be used on the client by Delver.ReturnRunnerWithName . Another thing cool about ClientEndpoints is that they behave like functions! Meaning on the client, if we did Runner:func() , it would return true - and to ensure that behavior, all of these functions yield. Leaving return nil in Endpoints Due to the networking library Delver uses, you must explicitly return a value in order for the client to not yield forever. Now that you know how to create Endpoints, let's learn how to use middleware! Just like ClientEndpoints, Middleware is a server-only entity however, the special thing is that Middleware allows for more control over how Delver handles internal requests for ClientEndpoints. To define Middleware in a server runner: Delver . addRunner ({... Middleware = { function ( plr , NameFunc , ...) -- runs first return plr , NameFunc , ... end , function ( plr , NameFunc , ...) -- runs second return nil -- drops remote request end , } ...}) Internally, whenever an endpoint request comes in, Delver calls these functions in order, and will drop the reqeust if a nil was solely returned. While argument injection can be useful, it is important to be aware of the dangers of mutating NameFunc . To cut a long story short, any mutation of the NameFunc may result in Delver dropping requests or completely choosing a different endpoint.","title":"Networking &amp; Middleware"},{"location":"Home/storing-data/","text":"Storing Data in Runners Assuming you did 1 & 2 \"challenges\" from \"Basic usage\", then you would have been punished in the face with the following error: RunnerName's key should not be global - add either _ or M_ as the first characters to silence However, why are we disallowed to attach data that is global? Well, it is a fix to a problem, a serious one that a lot of novice programmers run into. The Problem People often used attached data to other frameworks like Knit the same way they did with _G . And the problem is, that using _G is sinister, as it allows for unmanaged global state. It is easy to run into hard-to-find bugs with using such practices. The problem can be directly divided into: 1. Unreliability When you have unmanaged global state, you would never trust using it the second you put it. Why? Well, because every single code you ever write, including third-party code/libraries can mutate that state. 2. Encapsulation Breaks When other code accesses that global data, they can set it to whatever they seem needed which means direct manipulation is performed on the said data which is a very bad idea. Your external code should always go through your runner methods. 3. Change is Hard Let's represent this point in code: local class = { users = { id , id , id } } table.insert ( class . users , newid ) This is pretty basic, it is just inserting a new id into the users table of class . However, what is gonna happen if we just decided to use a hash/dictionary for faster fetching? Well, good luck, now you need to go through every place you read/write to that table to change it. We can solve this by doing: local class = { _users = {}, addUser = function ( self , id ) self . _users [ id ] = userStructre end , getUser = function ( self , id ) return self . _users [ id ] end } Now our external code doesn't care about how adding a new user is performed. It just tells class to add a new user entry. This means that we can change how we store data whenever we want, without recoding a lot of places! Fix: Data-Attaching Rules Now that you have seen how bad unmanaged global state can be, let's go through how Delver solves that issue! It does it by defining a few rules for how you would attach a data with a Runner. Before we start, let's use this dictonary for example: local dict = {} We want to add a new entry to it, and obviously that will require both a key and a value . In Delver, there are multiple rules that at least one of them need to be met for the key and the value valuables. For the key , it at least has to start with, given that the rules for value aren't met : _ -- To imply that the field is private, therefore, external code should never mess up with it. M_ -- to imply that the field is considered to be \"meta\" data, aka, this is the best place for attaching code that shouldn't be mutated by external code, and often times represents the parent dictionary state *(Runners' state in our case). For the value , it at least has to be: a function since functions are the preferred way of public data mutation. a table since tables are considered self-aware entities, and such, they are allowed to be public (although not recommended for mutation) an instance since instances are often represented as communicators such as bindables & remotes, although a user implementation might be better for your case.","title":"Storing Data in Runners"},{"location":"Home/storing-data/#storing-data-in-runners","text":"Assuming you did 1 & 2 \"challenges\" from \"Basic usage\", then you would have been punished in the face with the following error: RunnerName's key should not be global - add either _ or M_ as the first characters to silence However, why are we disallowed to attach data that is global? Well, it is a fix to a problem, a serious one that a lot of novice programmers run into.","title":"Storing Data in Runners"},{"location":"Home/storing-data/#the-problem","text":"People often used attached data to other frameworks like Knit the same way they did with _G . And the problem is, that using _G is sinister, as it allows for unmanaged global state. It is easy to run into hard-to-find bugs with using such practices. The problem can be directly divided into:","title":"The Problem"},{"location":"Home/storing-data/#1-unreliability","text":"When you have unmanaged global state, you would never trust using it the second you put it. Why? Well, because every single code you ever write, including third-party code/libraries can mutate that state.","title":"1. Unreliability"},{"location":"Home/storing-data/#2-encapsulation-breaks","text":"When other code accesses that global data, they can set it to whatever they seem needed which means direct manipulation is performed on the said data which is a very bad idea. Your external code should always go through your runner methods.","title":"2. Encapsulation Breaks"},{"location":"Home/storing-data/#3-change-is-hard","text":"Let's represent this point in code: local class = { users = { id , id , id } } table.insert ( class . users , newid ) This is pretty basic, it is just inserting a new id into the users table of class . However, what is gonna happen if we just decided to use a hash/dictionary for faster fetching? Well, good luck, now you need to go through every place you read/write to that table to change it. We can solve this by doing: local class = { _users = {}, addUser = function ( self , id ) self . _users [ id ] = userStructre end , getUser = function ( self , id ) return self . _users [ id ] end } Now our external code doesn't care about how adding a new user is performed. It just tells class to add a new user entry. This means that we can change how we store data whenever we want, without recoding a lot of places!","title":"3. Change is Hard"},{"location":"Home/storing-data/#fix-data-attaching-rules","text":"Now that you have seen how bad unmanaged global state can be, let's go through how Delver solves that issue! It does it by defining a few rules for how you would attach a data with a Runner. Before we start, let's use this dictonary for example: local dict = {} We want to add a new entry to it, and obviously that will require both a key and a value . In Delver, there are multiple rules that at least one of them need to be met for the key and the value valuables. For the key , it at least has to start with, given that the rules for value aren't met : _ -- To imply that the field is private, therefore, external code should never mess up with it. M_ -- to imply that the field is considered to be \"meta\" data, aka, this is the best place for attaching code that shouldn't be mutated by external code, and often times represents the parent dictionary state *(Runners' state in our case). For the value , it at least has to be: a function since functions are the preferred way of public data mutation. a table since tables are considered self-aware entities, and such, they are allowed to be public (although not recommended for mutation) an instance since instances are often represented as communicators such as bindables & remotes, although a user implementation might be better for your case.","title":"Fix: Data-Attaching Rules"}]}